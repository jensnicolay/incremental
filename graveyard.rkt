#lang racket
;      ((«vector-ref» _ x ae)
;       (let* ((v1 (eval-atom x ρ σ))
;              (v2 (eval-atom ae ρ σ))
;              (index v2)
;              (v (for/fold ((v ⊥)) ((w (γ v1)))
;                   (match w
;                     ((addr a)
;                      (for/fold ((v v)) ((ww (γ (store-lookup σ a))))
;                        (if (hash? ww)
;                            (for/fold ((v v)) (((key val) ww))
;                              (if (or (⊑ index key) (⊑ key index) )
;                                  (⊔ v val)
;                                  v))
;                            v)))
;                     (_ σ)))))
;         (continue v σ ι κ Ξ)))
;      ((«vector-set!» _ x ae1 ae2)
;       (let* ((v1 (eval-atom x ρ σ))
;              (v2 (eval-atom ae1 ρ σ))
;              (v3 (eval-atom ae2 ρ σ))
;              (σ* (for/fold ((σ σ)) ((w (γ v1)))
;                    (match w
;                      ((addr a)
;                       (for/fold ((σ σ)) ((ww (γ (store-lookup σ a))))
;                         (if (hash? ww)
;                             (store-update σ a (α (hash-set ww v2 (⊔ (hash-ref ww v2 ⊥) v3))))
;                             σ)))
;                      (_ σ)))))
;         (continue (α 'undefined) σ* ι κ Ξ)))
;      ((and («make-vector» _ ae1 ae2) e)
;       (let* ((v1 (eval-atom ae1 ρ σ))
;              (v2 (eval-atom ae2 ρ σ))
;              (a (alloc e κ))
;              (num v1)
;              (global (lattice-global lattice))
;              (lt-proc (lambda (x y)
;                         (for/fold ((result ⊥)) ((prim2 (γ (cdr (assoc "<" global)))) )
;                           (⊔ result ((prim2-proc prim2) x y)))))
;              (add-proc (lambda (x y)
;                          (for/fold ((result ⊥)) ((prim2 (γ (cdr (assoc "+" global))) ))
;                            (⊔ result ((prim2-proc prim2) x y)))))
;              (init v2)
;              (h (hash)))
;         (let loop ((h h) (i (α 0)) (σ σ))
;           (if (and (true? (lt-proc i num)) (not (hash-has-key? h i)))
;               (loop (hash-set h i init) (add-proc i (α 1)) σ)
;               (let* ((v (α h))
;                      (σ* (store-alloc σ a v)))
;                 (continue (α (addr a)) σ ι κ Ξ))))))
;
;    (define (prim-vector-length e rands σ ι κ Ξ continue)
;      (match rands
;        ((list x)
;         (let* ((global (lattice-global lattice))
;                (add-proc (lambda (x y)
;                            (for/fold ((result ⊥)) ((prim2 (γ (cdr (assoc "+" global)))))
;                              (⊔ result ((prim2-proc prim2) x y)))))
;                (lt-proc (lambda (x y)
;                           (for/fold ((result ⊥)) ((prim2 (γ (cdr (assoc "<" global)))))
;                             (⊔ result ((prim2-proc prim2) x y))))))
;           (let ((v (for/fold ((v ⊥)) ((w (γ x)))
;                      (match w
;                        ((addr a)
;                         (for/fold ((v v)) ((ww (γ (store-lookup σ a))))
;                           (if (hash? ww)
;                               (⊔ v (for/fold ((n (α 0))) ((i (in-set (hash-keys ww))))
;                                      (let ((ii (add-proc i (α 1))))
;                                        (if (lt-proc ii n)
;                                            n
;                                            ii))))
;                               v)))
;                        (_ v)))))
;             (continue v σ ι κ Ξ))))))
;    
;    (define (prim-vector-copy e rands σ ι κ Ξ continue)
;      (if (= (length rands) 1)
;          (let* ((v (for/fold ((v (hash))) ((w (γ (car rands))))
;                      (match w
;                        ((addr a)
;                         (for/fold ((v v)) ((ww (γ (store-lookup σ a))))
;                           (if (hash? ww)
;                               (hash-union v ww #:combine/key (lambda (k v0 v) (⊔ v0 v)))
;                               v)))
;                        (_ v))))
;                 (a-copy (alloc e e))
;                 (σ* (store-alloc a-copy (α v))))
;            (set (continue (α (addr a-copy)) σ* ι κ Ξ)))
;      (set)))
